// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

//本代码在thrift生成的server的模板基础上进行完善得
//实现了match_server的功能
//主要包含两方面：1. 作为服务器接受game的请求 2.
//作为客户端向save服务器发送保存数据的请求
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>

#include "match_server/Match.h"
#include "save_client/Save.h"

#include <condition_variable>
#include <iostream>
#include <mutex>
#include <queue>
#include <set>
#include <thread>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::match_service;
using namespace ::save_service;

using namespace std;

struct Task { //消息队列中存储的一个任务单元
    User user;
    string type; //任务类型
};

struct MessageQueue { //消息队列
    queue<Task> q;
    mutex m;               //互斥锁，实现互斥
    condition_variable cv; //条件变量，实现同步
                           //二者共同构成了OS中学习到的P(),V()操作
} mq;

class Pool { //玩家池
  private:
    vector<User> users;

  public:
    void add(const User &user) { users.push_back(user); }

    void remove(const User &user) {
        for (int i = 0; i < users.size(); i++) {
            if (users[i].id == user.id) {
                users.erase(users.begin() + i);
                break;
            }
        }
    }

    void match() {
        while (users.size() > 1) {
            //有两个人就匹配
            auto a = users[0], b = users[1];
            users.erase(users.begin());
            users.erase(users.begin());
            save_result(a.id, b.id);
        }
    }

    void save_result(int id1, int id2) {
        cout << "Match Result:" << id1 << ' ' << id2 << endl;

        std::shared_ptr<TTransport> socket(new TSocket("123.57.47.211", 9090));
        std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        SaveClient client(protocol);

        try {
            transport->open();

            client.save_data("acs_7699", "a179c9f0", id1,
                             id2); // user_name,password,player1_id,player2_id

            transport->close();
        } catch (TException &tx) {
            cout << "ERROR: " << tx.what() << endl;
        }
    }
} pool;

class MatchHandler : virtual public MatchIf {
  public:
    MatchHandler() {
        // Your initialization goes here
    }

    int32_t add_user(const User &user, const std::string &info) {
        // Your implementation goes here
        printf("add_user\n");

        unique_lock<mutex> lck(mq.m); //上锁
        //由于该类的析构函数中有解锁的操作，因此在add_user()执行完后直接帮我们进行了解锁操作
        mq.q.push({user, "add"});
        //唤醒被阻塞的线程（这里主要是consume_task()会被阻塞）
        mq.cv.notify_all();

        return 0;
    }

    int32_t remove_user(const User &user, const std::string &info) {
        // Your implementation goes here
        printf("remove_user\n");

        unique_lock<mutex> lck(mq.m);
        mq.q.push({user, "remove"});
        mq.cv.notify_all();

        return 0;
    }
};
void consume_task() {
    while (1) {
        unique_lock<mutex> lck(mq.m);
        if (mq.q.empty()) {
            //如果当前没有task，那么consume_task()应该被阻塞（等待新任务的添加）
            //否则就会导致consume_task一直循环，直到该线程的时间片用完，导致效率降低
            //注意这里实际上要先解锁的
            //否则在consume_task()等待任务的过程中，add_user()和remove_user()无法添加任务
            //但wait操作会帮我们执行解锁的过程
            mq.cv.wait(lck);
        } else {
            Task t = mq.q.front();
            mq.q.pop();
            lck.unlock(); //解锁
            //这里要提前解锁是为了在处理任务的过程中使得add_user()和remove_user()还能继续向队列中添加任务
            // do task
            if (t.type == "add")
                pool.add(t.user);
            else if (t.type == "remove")
                pool.remove(t.user);
            pool.match();
        }
    }
}

int main(int argc, char **argv) {
    int port = 9090;
    ::std::shared_ptr<MatchHandler> handler(new MatchHandler());
    ::std::shared_ptr<TProcessor> processor(new MatchProcessor(handler));
    ::std::shared_ptr<TServerTransport> serverTransport(
        new TServerSocket(port));
    ::std::shared_ptr<TTransportFactory> transportFactory(
        new TBufferedTransportFactory());
    ::std::shared_ptr<TProtocolFactory> protocolFactory(
        new TBinaryProtocolFactory());

    TSimpleServer server(processor, serverTransport, transportFactory,
                         protocolFactory);

    cout << "Start Match Server" << endl;

    thread matching_thread(consume_task);
    server.serve();
    return 0;
}

