// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

//本代码在thrift生成的server的模板基础上进行完善得
//实现了match_server的功能
//主要包含两方面：1. 作为服务器接受game的请求 2.
//作为客户端向save服务器发送保存数据的请求
#include <thrift/TToString.h>
#include <thrift/concurrency/ThreadFactory.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TTransportUtils.h>

#include "match_server/Match.h"
#include "save_client/Save.h"

#include <condition_variable>
#include <iostream>
#include <mutex>
#include <queue>
#include <set>
#include <thread>
#include <unistd.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::match_service;
using namespace ::save_service;

using namespace std;

struct Task { //消息队列中存储的一个任务单元
    User user;
    string type; //任务类型
};

struct MessageQueue { //消息队列
    queue<Task> q;
    mutex m;               //互斥锁，实现互斥
    condition_variable cv; //条件变量，实现同步
                           //二者共同构成了OS中学习到的P(),V()操作
} mq;

class Pool { //玩家池
  private:
    vector<User> users;

  public:
    void add(const User &user) { users.push_back(user); }

    void remove(const User &user) {
        for (int i = 0; i < users.size(); i++) {
            if (users[i].id == user.id) {
                users.erase(users.begin() + i);
                break;
            }
        }
    }

    void match() {
        sort(users.begin(), users.end(),
             [](User &a, User &b) { return a.score < b.score; });
        while (users.size() > 1) {
            //将当前分差<=50且最接近的两个人进行匹配
            bool exist = false; //记录当前的玩家池中是否存在分差<=50的两个人
            for (int i = 0; i < users.size() - 1; i++) {
                auto a = users[i];
                auto b = users[i + 1];
                if (b.score - a.score <= 50) {
                    users.erase(users.begin() + i, users.begin() + i + 2);
                    save_result(a.id, b.id);
                    exist = true;
                    break; //每次只进行一组匹配
                }
            }
            if (!exist) //如果不存在分差<=50的两个人，则停止循环，进行等待
                break;
        }
    }

    void save_result(int id1, int id2) {
        cout << "Match Result:" << id1 << ' ' << id2 << endl;

        std::shared_ptr<TTransport> socket(new TSocket(
            "123.57.47.211", 9090)); // 123.57.47.211为save服务器的地址
        std::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        std::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        SaveClient client(protocol);

        try {
            transport->open();

            client.save_data("acs_7699", "a179c9f0", id1,
                             id2); // user_name,password,player1_id,player2_id

            transport->close();
        } catch (TException &tx) {
            cout << "ERROR: " << tx.what() << endl;
        }
    }
} pool;

class MatchHandler : virtual public MatchIf {
  public:
    MatchHandler() {
        // Your initialization goes here
    }

    int32_t add_user(const User &user, const std::string &info) {
        // Your implementation goes here
        printf("add_user\n");

        unique_lock<mutex> lck(mq.m); //上锁
        //由于该类的析构函数中有解锁的操作，因此在add_user()执行完后直接帮我们进行了解锁操作
        mq.q.push({user, "add"});
        //唤醒被阻塞的线程（这里主要是consume_task()会被阻塞）
        mq.cv.notify_all();

        return 0;
    }

    int32_t remove_user(const User &user, const std::string &info) {
        // Your implementation goes here
        printf("remove_user\n");

        unique_lock<mutex> lck(mq.m);
        mq.q.push({user, "remove"});
        mq.cv.notify_all();

        return 0;
    }
};

class MatchCloneFactory : virtual public MatchIfFactory {
  public:
    ~MatchCloneFactory() override = default;
    MatchIf *
    getHandler(const ::apache::thrift::TConnectionInfo &connInfo) override {
        std::shared_ptr<TSocket> sock =
            std::dynamic_pointer_cast<TSocket>(connInfo.transport);
        return new MatchHandler;
    }
    void releaseHandler(MatchIf *handler) override {
        delete handler;
    }
};

void consume_task() {
    while (1) {
        unique_lock<mutex> lck(mq.m);
        if (mq.q.empty()) {
            //每隔1s就主动进行一次匹配（不论能否匹配上）
            pool.match();
            //匹配完成后要解锁，使得在间隔的1s内add_user()和remove_user()还能继续向队列中添加任务
            lck.unlock();
            sleep(1);
        } else {
            Task t = mq.q.front();
            mq.q.pop();
            lck.unlock(); //解锁
            //这里要提前解锁是为了在处理任务的过程中使得add_user()和remove_user()还能继续向队列中添加任务
            // do task
            if (t.type == "add")
                pool.add(t.user);
            else if (t.type == "remove")
                pool.remove(t.user);
            pool.match();
        }
    }
}

int main(int argc, char **argv) {
    int port = 9090;
    TThreadedServer server(std::make_shared<MatchProcessorFactory>(
                               std::make_shared<MatchCloneFactory>()),
                           std::make_shared<TServerSocket>(port),
                           std::make_shared<TBufferedTransportFactory>(),
                           std::make_shared<TBinaryProtocolFactory>());

    cout << "Start Match Server" << endl;

    thread matching_thread(consume_task);
    server.serve();
    return 0;
}

